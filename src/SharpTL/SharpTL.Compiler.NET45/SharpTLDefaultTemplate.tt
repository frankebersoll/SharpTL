<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="SharpTL.Compiler.Annotations" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the SharpTL compiler (https://github.com/Taggersoft/SharpTL).
//     Generated at <#=DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable 1591
namespace <#=_templateVars.Namespace #>
{
    using SharpTL;
	using SharpTL.BaseTypes;
    using System.Threading.Tasks;
    
    // TL constructors.

<#
    // Writing constructors with common types.
    WriteTLObjects(_templateVars.Schema.Constructors, _templateVars.Schema.Types);

    // Writing constructors without common types, because this is methods.
    // Hence method constructor is actually bunch of args to a method, which knows how to serialize itself.
    WriteTLObjects(_templateVars.Schema.Methods, null, true);
#>

    // TL types.

<#
foreach (TLType type in _templateVars.Schema.Types)
{
#>
    [TLType(<#=type.Constructors.Select(constructor => string.Format("typeof({0})", constructor.Name)).Aggregate((s, s1) => s + ", " + s1)
    #>)]
    public interface <#=type.Name #> : ITLObject
    {
<#
foreach (var parameter in type.Parameters)
{
#>
		<#=parameter.Type.Name #> <#= parameter.Name #> { get; }
<#
}
#>
    }

<#
}
#>

    /// <summary>
    ///     TL methods.
    /// </summary>
    public interface ITLMethods
    {
<#
    foreach (TLCombinator method in _templateVars.Schema.Methods)
    {
#>
        <#=method.Type.Name #> <#=method.Name #>(<#=method.Name #>Args args);
<#
    }
#>
    }

    /// <summary>
    ///     TL async methods.
    /// </summary>
    public interface ITLAsyncMethods
    {
<#
    foreach (TLCombinator method in _templateVars.Schema.Methods)
    {
        string returnType = method.Type.IsVoid ? "Task" : String.Format("Task<{0}>", method.Type.Name);
#>
        <#=returnType #> <#=method.Name #>Async(<#=method.Name #>Args args);
<#
    }
#>
    }
}
#pragma warning restore 1591
<#+[UsedImplicitly] private TemplateVars _templateVars; #>
<#+
private void WriteTLObjects(IEnumerable<TLCombinator> constructors, IEnumerable<TLType> types, bool isMethodsArgs = false)
{
    List<TLType> typesList = types != null ? types.ToList() : null;
    foreach (TLCombinator constructor in constructors)
    {
#>
    [TLObject(0x<#=constructor.Number.ToString("X8") #>)]
    public partial class <#=
    string.Format("{0}{1}", isMethodsArgs ? constructor.Name + "Args" : constructor.Name,
        (typesList != null && typesList.Contains(constructor.Type)) ? " : " + constructor.Type.Name : " : ITLObject")
    #>
    {
<#+
        int i = 0;
        foreach (TLCombinatorParameter parameter in constructor.Parameters)
        {
            TLSerializationMode? serModeOverride = parameter.Type.SerializationModeOverride;
#>
        [TLProperty(<#=++i #><#=serModeOverride.HasValue ? string.Format(", TLSerializationMode.{0}", serModeOverride.Value) : String.Empty #>)]
        public <#=parameter.Type.Name #> <#= parameter.Name #> { get; set; }

<#+
        } 
#>
    }

<#+
    }
}
#>
